/*! \page page_emergency_controller_ros Emergency Controller Ros

This page assumes you have understood <a href="page_emergency_controller.html">how to implement a emergency controller</a>.

<H3>Emergency Controller Ros Adaptee Implementation</H3>
In order to access the ros functionalities the controller has to inherit from roco::ControllerRos.
\code{c}
#include "roco/controllers/controllers.hpp"
namespace my_emergency_controller_ros {
class MyEmergencyControllerRos: virtual public roco::ControllerRos<my_model::State, my_model::Command>, public roco::EmergencyControllerAdapteeInterface {
...
};
}
\endcode

The implementation requirements are identical to emergency controllers.
However, roco::ControllerRos adds ros functionalities such as the getting/setting of the ros nodehandle.

<H3>Export Emergency Controller Ros as a Plugin</H3>
In order to use the plugin mechanism of the following three steps are required.

<H4>1. Export controller ros via macro </H4>
ROCOMA_EXPORT_EMERGENCY_CONTROLLER is replaced by ROCOMA_EXPORT_EMERGENCY_CONTROLLER_ROS when implementing a ros emergency controller.
\code{c}
#include "rocoma_plugin/rocoma_plugin.hpp"
ROCOMA_EXPORT_EMERGENCY_CONTROLLER_ROS(MyEmergencyControllerRosPlugin, my_model::State, my_model::Command, my_emergency_controller_ros::MyEmergencyControllerRos)
\endcode

<H4>2. Add a plugin description file </H4>
Compared to emergency controllers a different base class type <BR>rocoma_plugin::EmergencyControllerRosPluginInterface is used.
\code{xml}
<library path="lib/libmy_emergency_controller_ros">
  <class type="MyEmergencyControllerRosPlugin" base_class_type="rocoma_plugin::EmergencyControllerRosPluginInterface<my_model::State, my_model::Command>">
  </class>
</library>
\endcode

<H4>3. Export the plugin description file </H4>
<a href="page_controller.html">See standard controllers</a>
*/
